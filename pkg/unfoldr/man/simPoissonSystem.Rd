% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spheroid.R
\name{simPoissonSystem}
\alias{simPoissonSystem}
\title{Simulation of a Poisson germ-grain process}
\usage{
simPoissonSystem(theta, lam, size = "const", shape = "const",
  orientation = "rbetaiso", type = c("prolate", "oblate", "spheres",
  "cylinders"), rjoint = NULL, box = list(c(0, 1)), mu = c(0, 0, 1),
  dz = 0, n = c(0, 1, 0), intersect = c("original", "full", "only",
  "digi"), delta = 0.01, intern = FALSE, perfect = FALSE, pl = 0,
  label = "N")
}
\arguments{
\item{theta}{list of simulation parameters which must consist of elements: \code{size}, \code{shape} and \code{orientation}}

\item{lam}{mean number of objects per unit volume}

\item{size}{name of the size distribution function}

\item{shape}{name of the shape distribution function}

\item{orientation}{name of direction distribution function}

\item{type}{spheroid type, either "\code{prolate}" or "\code{oblate}" can be used}

\item{rjoint}{user-defined function, which specifies the (joint) distribution of the size, shape and orientation}

\item{box}{simulation box}

\item{mu}{main orientation axis, \code{mu=c(0,0,1)} (default), as the alignment of the coordinate system}

\item{dz}{distance of the intersecting plane to the origin}

\item{n}{normal vector of the intersting plane}

\item{intersect}{set "\code{full}" to return the simulated system together with section profiles as two lists named \code{S} and \code{sp} respectively,
choose "\code{only}" for section profiles only,
"\code{original}" for the 3D system only and "\code{digi}" for an integer matrix \code{W} as an discretized (binary) image
of section profiles}

\item{delta}{lattice constant for discretization, \code{0.01} (default)}

\item{intern}{logical, \code{FALSE} (default), whether to return only section profiles with centers inside the simulation window}

\item{perfect}{logical, \code{TRUE} (default), whether to simulate exactly (also called perfect)}

\item{pl}{integer, print level and return value type, see details}

\item{label}{character, a label set to each generated object, '\code{N}' (default)}
}
\value{
list of objects depending on the chosen return type defined by argument \code{intersect}
}
\description{
Simulation of a Poisson germ-grain process with either spheres, spheroids or spherocylinders as grains
}
\details{
The function simulates a Poisson germ-grain process given certain form parameters in the argument \code{theta}
and a predefined simulation box. The positions of the germs are generated independently according to a Poisson
process with mean intensity parameter \code{lam}. The function either generates \code{type="prolate"} or \code{type="oblate"}
spheroids, spheres or spherocylinders. The argument \code{size} sets the name of the distribution function of the size
of the objects, i.e. the semi-major axis lengths in case of spheroids, radii for spheres or the lengths of the main axis
of rotation for spherocylinders including the caps.

The following directional orientation distributions of the spheroid's major-axis or cylinder's main axis are available:
a uniform distribution (\code{runifdir}), isotropic random planar distribution (\code{rbetaiso}, see the reference below)
and a "von Mises-Fisher" (\code{rvMisesFisher}) distribution. The simulation box is a list containing the ranges of each box dimension
corresponding to the lower and upper limits in each direction. If the argument \code{box} contains only a single range, i.e. \code{list(c(0,1)}, the
same limits are assumed for the remaining dimensions. The argument \code{rjoint} names a (joint) distribution function which can be any function
provided by the user in order to generate the required random parameters for spheroids or spherocylinders, see below.

In addition, the function supports an exact simulation type [2] of the grains. In case of spheroids and spherocylinders setting \code{size="rbinorm"}
declares a bivariate normal size-shape distribution for which the exact simulation is available setting \code{perfect=TRUE}. More specifically,
for a bivariate normal vector \eqn{[X,Y]} with correlation parameter \eqn{\rho}, the length of the semi-major axis of a spheroid is given by \eqn{a=exp(x)}
with a (logit-transformed) shape parameter as \eqn{s=1/(1+exp(-y))} and thus a scaled semi-minor axis length \eqn{c=a*s}. This modification leads to a lognormally
distributed length of the semi-major axis. In case of spherocylinders, the lognormally distributed length of a cylinder is \eqn{len=h+2*r} where
\code{h} is the height and \eqn{r=len/2*s} the radius. The main direction \code{u} of the spheroid or spherocylinder is determined by the
major axis independent of size and shape. Also, the following univariate distributions of the length \code{a} and, respectively, \code{len},
the shape \code{s} are available: `\code{rbeta}`, `\code{rgamma}`, `\code{rlnorm}` and `\code{runif}`. One can also use "\code{const}" for a
simulation with constant lengths or shapes. Only simulations with size distributions `\code{rbinorm}` or `\code{rlnorm}` can use the exact
type of simulation (\code{perfect=TRUE}).

For spheres any distribution of the radii can be specified as a name of a user-defined function in \code{size} as long as the formal named
function parameters match the actual named parameters exactly as defined in the parameters given by \code{theta}.
Besides this, all other distributions given above are also available. In particular, setting \code{size="rlnorm"} leads to lognormally distributed
radii of the spheres in which case the exact simulation is available as an option (\code{perfect=TRUE}). Use "\code{const}" for a constant
radius of simulated spheres. 
 
The argument \code{pl>=0} denotes both the print level of intermediate output and the type of return value. If \code{pl=10}, then a shorter list
of spheroids or spheres is returned to speed up computation. Note that, the current implementation does not include routines for unfolding
the joint 3D size-shape-orientation distribution of spherocylinders so far.
}
\examples{
\dontrun{
## Comment: Simulate a Poisson spheroid system,
## 			intersect, discretize and display results
	
library(rgl)
library(plotrix)
library(unfoldr)

drawEllipses <- function(E, x=c(0,1), y=x, xlab="x",ylab="y", bg="gray", angle=0, ...) {
	Es <- sapply(E,
			function(x) {
				c("id"=x$id,
				  "x"=x$center[1],
				  "y"=x$center[2],
				  "phi"=x$phi,
				  "a"=x$ab[1],
				  "b"=x$ab[2])
			})
	
	plot(x,y, type="n",xlab=xlab,ylab=ylab)#,xaxs="i", yaxs="i")
	rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col=bg)
	
	if(angle>0) {
		M <- matrix( c(cos(angle), -sin(angle), sin(angle), cos(angle)), 2, 2 )
		XY <- matrix( c(Es["x",],Es["y",]), nc=2)  \%*\% M
		draw.ellipse(-XY[,1],XY[,2], Es["a",], Es["b",], angle=Es["phi",]+angle, deg=FALSE,...)
	} else  {
		draw.ellipse(Es["x",], Es["y",], Es["a",], Es["b",], angle=Es["phi",], deg=FALSE,...)
	}
	
	ret <- apply(Es,2,function(x) as.list(x))
	return ( ret )
}

col <- c("#0000FF","#00FF00","#FF0000","#FF00FF","#FFFF00","#00FFFF") 

## intensity
lam <- 100

# simulation bounding box
box <- list("xrange"=c(0,5),"yrange"=c(0,5),"zrange"=c(0,5))

# show how to call
head(simPoissonSystem)

####################################################################
## `rlnorm` distribution 
####################################################################

# log normal size, constant shape, isotropic orientation (rbetaiso) 
theta <- list("size"=list("meanlog"=-2.5,"sdlog"=0.5),
		"shape"=list("s"=0.5),
		"orientation"=list("kappa"=1))

## simulate and return full spheres system
## intersect with XZ plane and return full list of intersection profiles
S <- simPoissonSystem(theta,lam,size="rlnorm",box=box,type="oblate",
		intersect="original",mu=c(0,1,0),n=c(0,0,1),dz=0,perfect=TRUE,pl=101)

## show some objects to get an impression
open3d()
spheroids3d(S[1:1000], FALSE, TRUE, box=box, col=col)

###################################################################
## simulate bivariate size-shape distribution for prolate spheroids
###################################################################

## no `shape` required, isotropic orientation
theta <- list("size"=list("mx"=-2.5,"my"=0.5, "sdx"=0.35,"sdy"=0.25,"rho"=0.15),
		"orientation"=list("kappa"=1))

S <- simPoissonSystem(theta,lam,size="rbinorm",box=box,type="prolate",
		intersect="full", ,n=c(0,0,1), mu=c(0,0,1),
		"orientation"="rbetaiso", dz=2.5,perfect=TRUE,pl=101)

## 3D intersected objects
sp <- S$sp
id <- sapply(sp,"[[","id") 
open3d()
spheroids3d(S$S[id], FALSE, TRUE, box=box, col=col)
planes3d(0,0,-1,2.5,col="black",alpha=1)

## angle always w.r.t to x axis after simulation
phi <- sapply(sp,"[[","phi")
summary(phi)

## check rotation matrix ellipses
#E <- sp[[10]]
#V <- eigen(E$A)
#1/sqrt(V$values)
#
#A <- diag(c(1/E$ab[1]^2,1/E$ab[2]^2))
#B <- cbind(E$major,E$minor)
#t(B) \%*\% A \%*\% B
#E$A

dev.new()
Es <- drawEllipses(sp, x=box$xrange, y=box$yrange, border="black",xlab="[mm]", ylab="[mm]",
		bg="gray",col=col,	cex.lab=1.8,cex=1.8,cex.axis=1.8,nv=1000)

## digitized image
W <- S$W
dev.new()
image(1:nrow(W),1:ncol(W),W,col=gray(1:0))

##################################################################################
# general intersections (should be same as above)
##################################################################################

S <- S$S
SP <- intersectSystem(S, 2.5, n=c(0,0,1), intern=FALSE, pl=1)

## check compare 
str(sp[[100]])
str(SP[[100]])

#################################################################
## Vertical section
#################################################################

# vertical intersection
dz <- 2.5		# distance to origin of box [0,5]^3
n <- c(0,1,0)	# normal in y direction (xz plane)

theta$orientation$kappa <- 10	# random planar in xy plane

S <- simPoissonSystem(theta,lam,size="rbinorm",box=box,
		type="prolate", intersect="full", ,n=n, mu=c(0,0,1),
		"orientation"="rbetaiso", dz=dz, perfect=TRUE, intern=TRUE, pl=101)

sp <- S$sp # sections
id <- sapply(sp,"[[","id") 
open3d()
spheroids3d(S$S[id], FALSE, TRUE, box=box, col=col)
planes3d(0,-1,0,2.5,col="black",alpha=1)

# check angle
phi <- sapply(sp,"[[","phi")
summary(phi)

dev.new()
Es <- drawEllipses(sp, x=box$xrange, y=box$yrange, border="black",xlab="[mm]", ylab="[mm]",
		 bg="gray",col=col,	cex.lab=1.8,cex=1.8,cex.axis=1.8,nv=1000)
 
# intersect 3D system
Sp <- S$S   # spheroids
spv <- verticalSection(Sp,d=dz,n=n,intern=TRUE)

# angle in the intersecting plane always
# w.r.t. to mu=(0,0,1) used for unfolding
summary(spv$alpha) 

#################################################################
## Update intersection: find objects which intersect bounding box
#################################################################

idx <- updateIntersections(Sp)
sum(!idx)							# objects intersecting
id <- which( idx != 1)	

# show in 3D
open3d()
spheroids3d(Sp[id], FALSE, TRUE, box=box, col=col)

#################################################################
## user-defined simulation function
#################################################################

# no perfect simualtion here for 'rmulti'
# multivariate size distribution,
# independent orientation distribution 
rmulti <- function(m,s,kappa) {	
	# directional distribution
	# (implemented `rbetaiso` distribution)
	rbetaiso <- function(kappa) {
		phi <- runif(1,0,1)*2*pi
		q <- runif(1,0,1)
		theta=acos((1-2*q)/sqrt(kappa*kappa-(1-2*q)*(1-2*q)*(kappa*kappa-1)))
		list("u"=c(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)),
				"theta"=theta,"phi"=phi)					
	}
	
	dir <- rbetaiso(kappa)
	# log normal semi-major/semi-minor lengths
	M <- chol(s, pivot = TRUE)
	M <- M[,order(attr(M, "pivot"))]
	x <- exp(matrix(m,nrow=1) + matrix(rnorm(ncol(s)), nrow = 1, byrow = TRUE) \%*\% M)
	a <- min(x)
	b <- max(x)
	# the following elements are obligatory as a
	# return value for user-defined spheroid simulations
	list("a"=a,"b"=b,"c"=a,"u"=dir$u,"shape"=a/b,"theta"=dir$theta, "phi"=dir$phi)	
}


sigma <- matrix(c(0.1,0.1,0.1,0.25), ncol=2)
theta <- list("m"=c(-3.0,-2.0),"s"=sigma,"kappa"=0.5)

S <- simPoissonSystem(theta,lam,rjoint=rmulti,box=box,type="prolate",
		intersect="full",n=c(0,0,1), mu=c(0,0,1), dz=2.5, pl=101)

# in 3D
sp <- S$sp # sections
id <- sapply(sp,"[[","id") 
open3d()
spheroids3d(S$S[id], FALSE, TRUE, box=box, col=col)
planes3d(0,0,-1,2.5,col="black",alpha=1)

# in 2D
dev.new()
Es <- drawEllipses(sp, x=box$xrange, border="black",xlab="[mm]", ylab="[mm]",
		rot=0, bg="gray",col=col,	cex.lab=1.8,cex=1.8,cex.axis=1.8,nv=1000)

# digitized
W <- S$W
dev.new()
image(1:nrow(W),1:ncol(W),W,col=gray(1:0))
}
}
\references{
\itemize{
	\item{} {Ohser, J. and Schladitz, K. 3D images of materials structures Wiley-VCH, 2009}
     \item{} {C. Lantu\eqn{\acute{\textrm{e}}}joul. Geostatistical simulation. Models and algorithms.
					Springer, Berlin, 2002. Zbl 0990.86007}
	  }
}
\author{
M. Baaske
}
